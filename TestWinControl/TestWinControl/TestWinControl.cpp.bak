

//#include "stdafx.h"
// #include "DataTypeConv.h"
//#include "Global.h"
//#include "CExcelManager/CExcelManager.h"
// #include <stdio.h>  
// #include <stdlib.h>  
// #include <string.h>  
// #include <math.h>  
// #include <ctype.h>
//    
// #define MAX_LEN_MAC 18
// #define MAX_LEN_IP  16
//    
// typedef unsigned int uint;
// typedef long long llong;
//    
//    
// /** 
//  * 逆置字符串 
//  */ 
// void swapStr(char* info, int begin, int end)  
// {  
//     int i, j;  
//    
//     for (i = begin, j = end; i <= j; i++, j--) 
// 	{
//         if (info[i] != info[j])
// 		{
//             info[i] = info[i] ^ info[j];  
//             info[j] = info[i] ^ info[j];  
//             info[i] = info[i] ^ info[j];  
//         }
//     }
// }
// 
// /** 
//  * 字符串转整形 
//  */ 
// uint ipTint(char *ipstr)  
// {  
//     if (ipstr == NULL)  return 0;  
//     const char* split = ".";
//     char *token;  
//     int i = 3;
// 	uint total = 0;
// 	uint cur;  
// 
// //  // unsafe warning
// //     token = strtok(ipstr, split);  
// //    
// //     while (token != NULL) {  
// //         cur = atoi(token);  
// //         if (cur >= 0 && cur <= 255) {  
// //             total += cur * pow(256.0, i);  
// //         }  
// //         i--;  
// //         token = strtok(NULL, split);  
// //     }  
// 
// 	char* pNext = NULL;
// 	token = strtok_s(ipstr, split, &pNext);
// 
// 	while (token != NULL) {
// 		cur = atoi(token);
// 		if (cur >= 0 && cur <= 255) {
// 			total += cur * (uint)pow(256.0, i);
// 		}
// 		i--;
// 		token = strtok_s(NULL, split, &pNext);
// 	}
//    
//     return total;
// }  
//    
// /** 
//  * 整形转ip字符串 
//  */ 
// char* ipTstr(uint ipint)  
// {  
//     char *ipstr = (char *)malloc(MAX_LEN_IP);
//     memset(ipstr, '\0', MAX_LEN_IP);
// 	const char* split = ".";
//     ipstr[0] = '.';
// 	char token[4];
//     int bt = 0, ed = 0, len = 0, cur = 0;
//    
//     while (ipint) 
// 	{
//         cur = ipint % 256;
//         sprintf_s(token, "%d", cur);
//         strcat_s(ipstr, MAX_LEN_IP, token);  // strcat(ipstr, token);
//         ipint /= 256;  
//         if (ipint)  strcat_s(ipstr, MAX_LEN_IP, split);  // strcat(ipstr, ".");
//     }
//    
//     len = strlen(ipstr);
//     swapStr(ipstr, 0, len - 1);
//    
//     for (bt = ed = 0; ed < len;) 
// 	{
//         while (ed < len && ipstr[ed] != '.')
// 		{  
//             ed++;
//         }  
//         swapStr(ipstr, bt, ed - 1);
//         ed += 1;
//         bt = ed;
//     }  
//    
//     ipstr[len - 1] = '\0';
//    
//     return ipstr;  
// }  
// 
// llong macTint(char *ipstr)  
// {  
// 	if (ipstr == NULL)  return 0;  
// 	const char* split = ":";
// 	char *token;  
// 	int i = 5;
// 	uint cur;  
// 	llong total = 0;	// 12位mac地址需用long long存储
// 
// //  // unsafe warning
// // 	token = strtok(ipstr, ":");  
// // 	while (token != NULL) {  
// // 		cur = strtol(token, (char**)NULL, 16);
// // 		if (cur >= 0 && cur <= 255) {  
// // 			total += cur * pow(256.0, (int)i);
// // 		}  
// // 		i--;  
// // 		token = strtok(NULL, ":");  
// // 	}  
// 
// 	char* pNext = NULL;
// 	token = strtok_s(ipstr, split, &pNext);  
// 	while (token != NULL) {  
// 		cur = strtol(token, (char**)NULL, 16);
// 		if (cur >= 0 && cur <= 255) {  
// 			total += llong(cur * pow(256.0, i));
// 		}  
// 		i--;  
// 		token = strtok_s(NULL, split, &pNext);  
// 	}  
// 
// 	return total;  
// }  
// 
// char* macTstr(llong macint)  
// {  
// 	char *newStr = (char *)malloc(MAX_LEN_MAC);  
// 	memset(newStr, '\0', MAX_LEN_MAC);  
// 	const char* split = ":";
// 	char token[2];  
// 	int bt, ed, len, cur;  
// 
// 	while (macint) {  
// 		cur = macint % 256;
// 		sprintf_s(token, "%02x", cur);  
// //		swapStr(token, 0, 1);
// 		strcat_s(newStr, MAX_LEN_MAC, token); // strcat(newStr, token);  
// 		macint /= 256;  
// 		if (macint)  strcat_s(newStr, MAX_LEN_MAC, split);  // strcat(newStr, ":");
// 	}  
// 
// 	len = strlen(newStr);
// 	swapStr(newStr, 0, len - 1);
// 
// 	for (bt = ed = 0; ed < len;) {
// 		while (ed < len && newStr[ed] != ':') {
// 			ed++;
// 		}
// 		swapStr(newStr, bt, ed - 1);
// 		ed += 1;
// 		bt = ed;
// 	}
// 
// 	newStr[len - 1] = '\0';
// 
// 	return newStr;  
// }  

//将TCHAR转为char   
//*tchar是TCHAR类型指针，*_char是char类型指针   

// int main(void)  
// {  
//
// dataTypeConv
//  	CString srcCString("0020");
//  	int s_dec = CStringToDec(srcCString);
//  	int s_hex = CStringToHex(srcCString);
//  
//  	char* srcChar = "0020";
//  	int c_dec = CharToDec(srcChar);
//  	int c_hex = CharToHex(srcChar);
//  
//  	TCHAR* srcTChar = _T("0020");
// 	char* dstChar = new char[wcslen(srcTChar)+1];
// 	TCharToChar(srcTChar, dstChar);
// 	TCHAR* dstTChar = new TCHAR[strlen(srcChar)+1];
// 	CharToTChar(srcChar, dstTChar);
// 	int t_dec = TCharToDec(srcTChar);
// 	int t_hex = TCharToHex(srcTChar);
//  
//  	char* c_test = CStringToChar(srcCString);
//  	CString s_test = CharToCString(srcChar);
//  
//  	CString szTemp = DecToCString(123);
//  	string strtemp = "asdfccc";
//  	szTemp = StringToCString(strtemp);
//  	strtemp = CStringToString(s_test);
// 
// 	char* macStr = "d4-3e-7e-bb-c9-1b";
// 	macStr = "d4:3e:7e-bb-c9-1b";
// 	char* ipStr = "192.168.167.229";
// 	long long macInt = MacToNum(macStr);
// 	CString szMac = NumToCStringMac(macInt);
//  	long long ipInt = IpToNum(ipStr);
// 	CString szIp = NumToCStringIp(ipInt);
//  
//  	char* char2String = "Char";
//  	string string2Char = CharToString(char2String);
//  	string2Char = "String to char";
//  	char2String = StringToChar(string2Char);
// 
// 	int srcInt = 123456;
// 	dstChar = DecToChar(srcInt);
// 	dstChar = HexToChar(srcInt);



// 	const double pi = 3.141592657;
// 
// 	// 1、 三角函数
// 	double sin_45 = sin(pi/4);
// 	double cos_45 = cos(pi/4);
// 	double tan_45 = tan(pi/4);
// 	// 2 、反三角函数
// 	double asin_45 = asin(sin_45);
// 	double acos_45 = acos(cos_45);
// 	double atan_45 = atan(tan_45);
// 	double atan2_45 = atan2(1.0, 1.0);	// 返回给定的 X 及 Y 坐标值的反正切值。此处即pi/4
// 	//3 、双曲三角函数
// 	double sinh_45 = sinh(0.5);
// 	double cosh_45 = cosh(1.0);
// 	double tanh_45 = tanh(1.0);

//	const double pi = atan(1.0)*4.0;
//	CString exePath = GetExePath();

、

// #include <atlstr.h>
// #pragma comment(lib, "version.lib")
// 
// struct EXE_FILE_INFO  
// {
// 	CString CompanyName;
// 	CString FileDescription;
// 	CString FileVersion;
// 	CString InternalName;
// 	CString LegalCopyright;
// 	CString OriginalFilename;
// 	CString ProductName;
// 	CString ProductVersion;
// 	// no means...
// 	CString Comments;
// 	CString LegalTrademarks;
// 	CString PrivateBuild;
// 	CString SpecialBuild;
// 
// };
// 
// BOOL GetExeFileInfo(EXE_FILE_INFO& fileInfo, CString exePath)
// {
//     DWORD dwLen = 0;
//     char* lpData = NULL;
// 
//     dwLen = GetFileVersionInfoSize(exePath, 0);
//     if (0 == dwLen)	return FALSE;
// 
//     lpData = new char[dwLen+1];
// 
//     if(!GetFileVersionInfo(exePath, 0, dwLen, lpData))
//     {
//         delete lpData;
//         return FALSE;
//     }
// 
//     LPVOID lpBuffer = NULL;
//     UINT uLen = 0;
// 	CString subBlock;
// 	subBlock.Format(_T("\\StringFileInfo\\%s04b0\\"), _T("0804"));	// 0409英文,0804中文
//     BOOL b1 = VerQueryValue(lpData, subBlock + _T("CompanyName"), &lpBuffer, &uLen); 
// 	fileInfo.CompanyName = (TCHAR*)lpBuffer;
// 	BOOL b2 = VerQueryValue(lpData, subBlock + _T("FileDescription"), &lpBuffer, &uLen); 
// 	fileInfo.FileDescription = (TCHAR*)lpBuffer;
// 	BOOL b3 = VerQueryValue(lpData, subBlock + _T("FileVersion"), &lpBuffer, &uLen); 
// 	fileInfo.FileVersion = (TCHAR*)lpBuffer;
// 	BOOL b4 = VerQueryValue(lpData, subBlock + _T("InternalName"), &lpBuffer, &uLen); 
// 	fileInfo.InternalName = (TCHAR*)lpBuffer;
// 	BOOL b5 = VerQueryValue(lpData, subBlock + _T("LegalCopyright"), &lpBuffer, &uLen); 
// 	fileInfo.LegalCopyright = (TCHAR*)lpBuffer;
// 	BOOL b6 = VerQueryValue(lpData, subBlock + _T("OriginalFilename"), &lpBuffer, &uLen); 
// 	fileInfo.OriginalFilename = (TCHAR*)lpBuffer;
// 	BOOL b7 = VerQueryValue(lpData, subBlock + _T("ProductName"), &lpBuffer, &uLen); 
// 	fileInfo.ProductName = (TCHAR*)lpBuffer;
// 	BOOL b8 = VerQueryValue(lpData, subBlock + _T("ProductVersion"), &lpBuffer, &uLen); 
// 	fileInfo.ProductVersion = (TCHAR*)lpBuffer;
// 
// 	// no means...
// 	BOOL b9 = VerQueryValue(lpData, subBlock + _T("Comments"), &lpBuffer, &uLen); 
// 	fileInfo.Comments = (TCHAR*)lpBuffer;
// 	BOOL b10 = VerQueryValue(lpData, subBlock + _T("LegalTrademarks"), &lpBuffer, &uLen); 
// 	fileInfo.LegalTrademarks = (TCHAR*)lpBuffer;
// 	BOOL b11 = VerQueryValue(lpData, subBlock + _T("PrivateBuild"), &lpBuffer, &uLen); 
// 	fileInfo.PrivateBuild = (TCHAR*)lpBuffer;
// 	BOOL b12 = VerQueryValue(lpData, subBlock + _T("SpecialBuild"), &lpBuffer, &uLen); 
// 	fileInfo.SpecialBuild = (TCHAR*)lpBuffer;
//     if (!b1)
//     {
//         return FALSE;
//     }
// 
//     delete [] lpData;
//     return TRUE;
// }
// 
// LPCTSTR GetExePath(void)
// {	
// 	// 获取主程序所在路径, 存在path中
// 	TCHAR path[MAX_PATH];
// 	GetModuleFileName(NULL, path, MAX_PATH);
// 	return CString(path);
// }
// 
// int main(void)
// {
// 	EXE_FILE_INFO fileInfo;
// 	GetExeFileInfo(fileInfo, _T("D:\\000\\桌面\\SnapShot.exe"));
// 	return 0;
// }

// 
// #include <windows.h>   
// #include <Winnetwk.h>   
// #include <stdio.h>   
// #pragma comment(lib, "Ws2_32.lib")   
// #pragma comment(lib, "Mpr.lib")   
// 
// BOOL GetIpAddress(char *hostname)   
// {   
// 	HOSTENT *lpHost = NULL;   
// 	struct sockaddr_in dest;   
// 
// 	lpHost = gethostbyname(hostname);   
// 	if   (lpHost == NULL)   
// 	{   
// 		printf("gethostbyname failed: %d", WSAGetLastError());   
// 	}   
// 	else   
// 	{   
// 		for(int i=0; lpHost->h_addr_list[i] != NULL ;i++)   
// 		{   
// 			memcpy(&(dest.sin_addr), lpHost->h_addr_list[i], lpHost->h_length);   
// 			printf("IP address is: %s", inet_ntoa(dest.sin_addr));   
// 		}   
// 	}   
// 	return TRUE;   
// }   
// BOOL WINAPI EnumerateFunc(LPNETRESOURCE   lpnr)   
// {   
// 	HANDLE hEnum;  
// 	DWORD  dwIndex, dwResult,dwBufferSize = 16384, dwNumEntries = 0xFFFFFFFF;     //   Enumerate   all   possible   entries.   
// 	LPNETRESOURCE lpnrLocal;                     //   Pointer   to   enumerated   structures.   
// 
// 	dwResult = WNetOpenEnum   (   
// 		RESOURCE_GLOBALNET,   //   All   resources   on   the   network   
// 		RESOURCETYPE_ANY,     //   All   resources     
// 		0,                    //   Enumerate   all   resources.   
// 		lpnr,                 //   The   container   to   enumerate   
// 		&hEnum);              //   Handle   to   resource   
// 	if(dwResult != ERROR_SUCCESS)    return   FALSE;   
// 
// 	//   Allocate memory for  NETRESOURCE structures.   
// 	if(!(lpnrLocal =   (LPNETRESOURCE)   LocalAlloc   (LPTR,   dwBufferSize)))   
// 		printf("Not   enough   memory");   
// 
// 	do     
// 	{   
// 		dwResult   =   WNetEnumResource   (   
// 			hEnum,                             //   Resource   handle   
// 			&dwNumEntries,             //   Number   of   entries   
// 			lpnrLocal,                     //   LPNETRESOURCE   
// 			&dwBufferSize);           //   Buffer   size   
// 
// 		if   (dwResult   ==   ERROR_SUCCESS)     
// 		{   
// 			for   (dwIndex   =   0;   dwIndex   <   dwNumEntries;   dwIndex++)   
// 			{   
// 				printf("\nRemote   Name:%s   Comment:   %s",   lpnrLocal[dwIndex].lpRemoteName,   
// 					lpnrLocal[dwIndex].lpComment);   
// 
// 				int Cnt = WideCharToMultiByte(CP_OEMCP, NULL, lpnrLocal[dwIndex].lpRemoteName+2, -1, NULL, 0, NULL, FALSE);
// 				char *szTemp;
// 				szTemp = new char[Cnt];
// 				WideCharToMultiByte (CP_OEMCP, NULL, lpnrLocal[dwIndex].lpRemoteName+2, -1, szTemp, Cnt, NULL, FALSE);
// 
// 				GetIpAddress(szTemp+2);   
// 				delete[] szTemp;
// 
// 			}   
// 		}   
// 		else   if   (dwResult   !=   ERROR_NO_MORE_ITEMS)     
// 			break;   
// 	}     
// 	while(dwResult   !=   ERROR_NO_MORE_ITEMS);   
// 	LocalFree   (lpnrLocal);   
// 	WNetCloseEnum   (hEnum);   
// 	return   TRUE;   
// }     
// 
// int   main(int   argc,   char*   argv[])   
// {   
// 	WORD   wVersionRequested;   
// 	WSADATA   wsaData;   
// 	int   err;   
// 	wVersionRequested   =   MAKEWORD(   2,   2   );   
// 	err   =   WSAStartup(   wVersionRequested,   &wsaData   );   
// 	if   (   err   ==   0   )     
// 	{   
// 		NETRESOURCE   nr;   
// 		nr.dwScope   =   RESOURCE_GLOBALNET;   
// 		nr.dwType   =   RESOURCETYPE_DISK;       
// 		nr.dwUsage   =   RESOURCEUSAGE_CONTAINER;   
// 		nr.lpLocalName   =   TEXT("");   
// 		nr.lpRemoteName   =   TEXT("OPTO");//这里改为你的域名   
// 		nr.lpComment   =   TEXT("");   
// 		nr.lpProvider   =   TEXT("");   
// 		EnumerateFunc   (&nr);     
// 	}   
// 	return   0;   
// }  

// #include "stdafx.h"
// #include "MailManager/MailMessage.h"
// #include "MailManager/SMTP.h"
// #include <MAPI.h>
// #pragma comment(lib, "MAPI32.DLL")
// int main(void)
// {
// 	//新建CMailMessage对象，并初始化
// 	CMailMessage msg;
// 	msg.m_sFrom = _T("lixinccm@trulyopto.cn");
// 	msg.AddMultipleRecipients( _T("lixinccm@trulyopto.cn") );
// 	msg.m_sSubject = _T("test");
// 	msg.m_sBody = _T("Naked");
// 
// 	//建立CSMTP对象
// 	CSMTP smtp(_T("smtp.trulyopto.cn")); // 
// 	//连接SMTP服务器
// 	if( !smtp.Connect() )
// 	{
// 		AfxMessageBox( smtp.GetLastError() );
// 		return 0;
// 	}
// 
// 	//发信
// 	if( !smtp.SendMessage( &msg ) )
// 	{
// 		AfxMessageBox( smtp.GetLastError() );
// 		return 0;
// 	}
// 
// 	//断开连接
// 	if( !smtp.Disconnect() )
// 	{
// 		AfxMessageBox( smtp.GetLastError() );
// 		return 0;
// 	}
// 	AfxMessageBox( _T( "Message Sent Successfully") );
// 	LHANDLE loghandle;
// 	ULONG res = MAPILOGON( 0,NULL,NULL,0,0,&loghandle );
// 	CString ss;
// 	ss.Format( _T("%d"),res );
// 	CString strsubject,strbody;
// 	strsubject =  _T("test");;
// 	strbody = _T("body content");
// 	CTime time = CTime::GetCurrentTime();
// 	CString strtime = time.Format( _T("%y//%m//%d//%H") );
// 	CString address1,address2;
// 	
// 	CString user = _T("lixinccm");
// 	address2 = _T("SMTP:") + user + _T("@trulyopto.cn");
// 
// 	MapiMessage message;
// 	//subject of the mail
// 	message.lpszSubject = "test";
// 	//body of the mail
// 	message.lpszNoteText = "body content";
// 	message.lpszMessageType = NULL;
// 	//time sending
// 	USES_CONVERSION;
// 	message.lpszDateReceived = T2A(strtime.GetBuffer(0));
// 
// 	message.lpszConversationID = NULL;
// 	message.flFlags = MAPI_SENT;
// 	//sender message
// 	message.lpOriginator = NULL;
// 	message.nRecipCount = 1;//reciver count
// 	MapiRecipDesc reci = { 0,MAPI_TO, T2A(address1.GetBuffer(0)), T2A(address2.GetBuffer(0)),0,NULL };
// 	//IMessage::
// 	//MapiRecipDesc reci1 = { 0,MAPI_TO,add1.GetBuffer(0),add2.GetBuffer(0),0,NULL };
// 	message.lpRecips = &reci;
// 	// message.lpRecips = &reci1;
// 	message.lpFiles = 0;//attachment
// 	message.nFileCount = 0;//attachment count
// 
// 	int lresult = MAPISENDMAIL( loghandle,0,&message,0,0);
// }


// 操作Excel
// #include "stdafx.h"
// #include "CExcelManager/ExcelManager.h"
// 
// int main()
// {
// 	// Excel 操作
// 	CExcelManager excel;
// 	excel.InitApp();
// 	excel.OpenExcel(_T("D:\\000\\桌面\\DriverIC.xls"));
// 	excel.OpenSheet(1);
// 	excel.CreateExcel(_T("D:\\000\\桌面\\Test.xls"));
// 	excel.SetCellString(1, 1, _T('x'));
// 	CString sz = excel.GetCellString(1, 1);
// 	excel.ReleaseApp();
// 	
// 	
// 
// 	return 0;
// }

// #include "stdafx.h"
// #include "CTimeManager/TimeManager.h"
//
// int main()
// {
// 	CTimeManager tim;
// 	tim.GetCurDateString();
// 	int curDayIndex = tim.GetCurDayIndexOfYear();
// 	CString date = _T("2000:12:02");
// 	int dayIndex = tim.GetDayIndexOfYear(date);
//  	CString temp4 = tim.GetDateAfterToday(365);
// 	CString temp3 = tim.GetDateAfterToday(730);
//  	CString temp = tim.GetDateAfterToday(1095);
//  	CString temp1 = tim.GetDateAfterToday(2000);
// 
// 	return 0;
// }

// #include "stdafx.h"
// 
// int main()
// {
// 	return 0;
// }

// #include "stdafx.h"
// #include <stdio.h>
// #include <string.h>
// 
// const int maxn = 3000;
// struct bign
// {
// 	int len, s[maxn];
// 	bign() {memset(s, 0, sizeof(s)); len = 1;}
// 	bign operator = (const char* num)
// 	{
// 		len = strlen(num);
// 		for (int i = 0; i < len; i++)
// 			s[i] = num[len-i-1] - '0';
// 		return *this;
// 	}
// };
// 
// #include <setjmp.h>
// int main()
// {
// 	jmp_buf xxx;
// 	setjmp(xxx);
// 	int i;
// 	int j;
// 	int x;
// 	int y;
// 	printf("The stack top is near %#X\n%#X\n%#X\n%#X\n", &i,&j,&x,&y);
// 	longjmp(xxx, 1);
// 	return 0;
// }

 1 #include <iostream>
 2 #include <string>
 3 #include <stdint.h>
 4 
 5 using namespace std;
 6 
 7 string BinToHex(const string &strBin, bool bIsUpper = false)
 8 {
 9     string strHex;
10     strHex.resize(strBin.size() * 2);
11     for (size_t i = 0; i < strBin.size(); i++)
12     {
13         uint8_t cTemp = strBin[i];
14         for (size_t j = 0; j < 2; j++)
15         {
16             uint8_t cCur = (cTemp & 0x0f);
17             if (cCur < 10)
18             {
19                 cCur += '0';
20             }
21             else
22             {
23                 cCur += ((bIsUpper ? 'A' : 'a') - 10);
24             }
25             strHex[2 * i + 1 - j] = cCur;
26             cTemp >>= 4;
27         }
28     }
29 
30     return strHex;
31 }
32 
33 string HexToBin(const string &strHex)
34 {
35     if (strHex.size() % 2 != 0)
36     {
37         return "";
38     }
39 
40     string strBin;
41     strBin.resize(strHex.size() / 2);
42     for (size_t i = 0; i < strBin.size(); i++)
43     {
44         uint8_t cTemp = 0;
45         for (size_t j = 0; j < 2; j++)
46         {
47             char cCur = strHex[2 * i + j];
48             if (cCur >= '0' && cCur <= '9')
49             {
50                 cTemp = (cTemp << 4) + (cCur - '0');
51             }
52             else if (cCur >= 'a' && cCur <= 'f')
53             {
54                 cTemp = (cTemp << 4) + (cCur - 'a' + 10);
55             }
56             else if (cCur >= 'A' && cCur <= 'F')
57             {
58                 cTemp = (cTemp << 4) + (cCur - 'A' + 10);
59             }
60             else
61             {
62                 return "";
63             }
64         }
65         strBin[i] = cTemp;
66     }
67 
68     return strBin;
69 }
70 
71 int main()
72 {
73     string strBin = "!@#$%^&*()_+~`1234567890-=";
74     string strHex = "21402324255E262A28295F2B7E60313233343536373839302D3D";
75 
76     string strBinToHex = BinToHex(strBin);
77     cout << strBinToHex << endl;
78     strBinToHex = BinToHex(strBin, true);
79     cout << strBinToHex << endl;
80 
81     string strHexToBin = HexToBin(strHex);
82     cout << strHexToBin << endl;
83 
84     return 0;
85 }